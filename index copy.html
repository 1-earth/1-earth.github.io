<!DOCTYPE html>
<html>
<head>
  <title>Community Initiatives Network Map</title>
  <style>
    canvas {
      border: 1px solid black;
    }
    #tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 5px;
      border-radius: 5px;
      display: none;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <canvas id="networkCanvas" width="800" height="600"></canvas>
  <div id="tooltip"></div>
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      const API_KEY = "AIzaSyB5b_wv4yQMDoHTCDDZydcbYxLZ5ISrGbQ";
      const SPREADSHEET_ID = "1Cy2EdQwPH-GErwqtC3tD6QvX40kcyCmhuRg5G7wIw_g";
      const RANGE = "Events";

      async function fetchData() {
        const response = await fetch(
          `https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${RANGE}?key=${API_KEY}`
        );
        const data = await response.json();
        return data.values.slice(1); // Skip header row
      }

      function groupByKeywords(initiatives) {
        const clusters = {};
        initiatives.forEach((initiative, index) => {
          const keywords = initiative.slice(0, 2).concat(initiative.slice(5, 7), initiative.slice(11, 13)).join(',').split(',').map(k => k.trim());
          keywords.forEach(keyword => {
            if (!clusters[keyword]) {
              clusters[keyword] = [];
            }
            clusters[keyword].push({ ...initiative, index, keywords });
          });
        });
        return clusters;
      }

      function drawNetwork(canvas, initiatives) {
        const ctx = canvas.getContext("2d");
        const nodes = [];
        const connections = [];
        const tooltip = document.getElementById("tooltip");

        const clusters = groupByKeywords(initiatives);

        // Calculate node positions based on clusters
        let clusterIndex = 0;
        const clusterSpacing = 200; // Adjust spacing between clusters
        const nodeSpacing = 50; // Adjust spacing within clusters

        for (const keyword in clusters) {
          const clusterNodes = clusters[keyword];
          const angleIncrement = (2 * Math.PI) / clusterNodes.length;
          const clusterCenterX = (clusterIndex % 4) * clusterSpacing + clusterSpacing / 2;
          const clusterCenterY = Math.floor(clusterIndex / 4) * clusterSpacing + clusterSpacing / 2;
          
          clusterNodes.forEach((node, i) => {
            const angle = i * angleIncrement;
            const x = clusterCenterX + nodeSpacing * Math.cos(angle);
            const y = clusterCenterY + nodeSpacing * Math.sin(angle);
            nodes.push({ ...node, x, y, keyword });
          });

          clusterIndex++;
        }

        // Determine connections based on shared keywords
        nodes.forEach((node, index) => {
          nodes.forEach((otherNode, otherIndex) => {
            if (index !== otherIndex && node.keywords && otherNode.keywords && node.keywords.some(k => otherNode.keywords.includes(k))) {
              connections.push({ source: node, target: otherNode });
            }
          });
        });

        // Draw connections
        connections.forEach(connection => {
          ctx.beginPath();
          ctx.moveTo(connection.source.x, connection.source.y);
          ctx.lineTo(connection.target.x, connection.target.y);
          ctx.strokeStyle = `rgba(0, 0, 0, 0.2)`;
          ctx.stroke();
        });

        // Draw nodes
        nodes.forEach(node => {
          ctx.beginPath();
          ctx.arc(node.x, node.y, 5, 0, 2 * Math.PI, false);
          ctx.fillStyle = 'blue';
          ctx.fill();
          ctx.strokeStyle = 'blue';
          ctx.stroke();
        });

        // Add interactivity
        canvas.addEventListener('mousemove', function (event) {
          const rect = canvas.getBoundingClientRect();
          const mouseX = event.clientX - rect.left;
          const mouseY = event.clientY - rect.top;

          let hoveredNode = null;
          nodes.forEach(node => {
            const dx = node.x - mouseX;
            const dy = node.y - mouseY;
            if (Math.sqrt(dx * dx + dy * dy) < 5) {
              hoveredNode = node;
            }
          });

          if (hoveredNode) {
            tooltip.style.display = 'block';
            tooltip.style.left = `${event.clientX + 10}px`;
            tooltip.style.top = `${event.clientY + 10}px`;
            tooltip.innerHTML = `
              <strong>${hoveredNode[0]}</strong><br>
              ${hoveredNode[1]}<br>
              ${hoveredNode[2]} ${hoveredNode[3]}<br>
              ${hoveredNode[5]}
            `;
          } else {
            tooltip.style.display = 'none';
          }
        });
      }

      async function init() {
        const initiatives = await fetchData();
        const canvas = document.getElementById("networkCanvas");
        drawNetwork(canvas, initiatives);
      }

      init();
    });
  </script>
</body>
</html>
